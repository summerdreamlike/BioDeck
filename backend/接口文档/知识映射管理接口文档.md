# 知识映射管理接口文档

## 概述
- 模块：知识映射管理
- 作用：维护 关卡↔知识点 与 知识点↔卡牌 映射，供抽卡概率调整使用
- 认证：所有接口需要携带 JWT（Authorization: Bearer <token>）
- 前缀：`/api/v1`

## 关卡 ↔ 知识点

### 获取关卡对应的知识点
- 方法：GET
- 路径：`/knowledge/levels/{level_name}`
- 请求参数：无（path 提供 `level_name`）
- 响应：
```json
{
  "code": 0,
  "message": "成功",
  "data": [
    { "knowledge_point": "细胞分裂基础", "level_name": "有丝分裂", "created_at": "2025-09-05T08:00:00" }
  ]
}
```

### 新增/更新关卡-知识点映射
- 方法：POST
- 路径：`/knowledge/levels`
- 请求体：
```json
{ "level_name": "有丝分裂", "knowledge_point": "细胞分裂基础" }
```
- 响应：
```json
{ "code": 0, "message": "关卡-知识点映射已保存", "data": { "level_name": "有丝分裂", "knowledge_point": "细胞分裂基础" } }
```

### 删除关卡-知识点映射
- 方法：DELETE
- 路径：`/knowledge/levels`
- 请求体：
```json
{ "level_name": "有丝分裂", "knowledge_point": "细胞分裂基础" }
```
- 响应：
```json
{ "code": 0, "message": "关卡-知识点映射已删除", "data": { "deleted": true } }
```

## 知识点 ↔ 卡牌

### 获取知识点对应卡牌
- 方法：GET
- 路径：`/knowledge/cards/{knowledge_point}`
- 请求参数：无（path 提供 `knowledge_point`）
- 响应：
```json
{
  "code": 0,
  "message": "成功",
  "data": [
    { "knowledge_point": "细胞分裂基础", "card_id": "B001", "relevance": 1.0, "created_at": "2025-09-05T08:00:00" }
  ]
}
```

### 新增/更新知识点-卡牌映射
- 方法：POST
- 路径：`/knowledge/cards`
- 请求体：
```json
{ "knowledge_point": "细胞分裂基础", "card_id": "B001", "relevance": 1.2 }
```
- 说明：若映射已存在，更新 `relevance`；否则新增
- 响应：
```json
{ "code": 0, "message": "知识点-卡牌映射已保存", "data": { "knowledge_point": "细胞分裂基础", "card_id": "B001", "relevance": 1.2 } }
```

### 删除知识点-卡牌映射
- 方法：DELETE
- 路径：`/knowledge/cards`
- 请求体：
```json
{ "knowledge_point": "细胞分裂基础", "card_id": "B001" }
```
- 响应：
```json
{ "code": 0, "message": "知识点-卡牌映射已删除", "data": { "deleted": true } }
```

## 导入脚本
- 脚本路径：`backend/scripts/import_knowledge_mappings.py`
- 用法：`python backend/scripts/import_knowledge_mappings.py backend/scripts/knowledge_mappings.sample.json`
- JSON 示例：参见 `backend/scripts/knowledge_mappings.sample.json`

## 抽卡概率调整算法
- **核心目标**：当学生在某些关卡失败次数越多，与这些关卡相关知识点对应的卡牌在抽卡时概率越高。
- **影响范围**：只在已选定稀有度池内对具体卡牌的相对权重进行提升，不改变各稀有度总体概率。
- **常量**：
  - `BOOST_PER_FAIL = 0.05`（每次失败 +5% 权重加成）
  - `MAX_CARD_BOOST = 0.5`（单卡总加成上限 +50%）

- **计算步骤**：
  1. 按 `rarity_drop_config` 进行稀有度抽取（不受失败次数影响）。
  2. 查询被选稀有度下的全部卡牌（基础权重为卡牌 `drop_rate`，若为空则用 1.0）。
  3. 读取该用户的关卡失败次数映射：`{ level_name: failure_count }`（失败为 0 的关卡忽略）。
  4. 关卡 → 知识点：聚合相关关卡的失败次数到知识点上，得到 `kp_fail_weight[kp] = Σ failure_count(level in kp)`。
  5. 知识点 → 卡牌：按映射表与 `relevance`（相关性权重）把失败权重传递给卡牌：
     - `card_boost[card_id] += kp_fail_weight[kp] * BOOST_PER_FAIL * relevance`
     - 并截断到上限：`card_boost[card_id] = min(card_boost[card_id], MAX_CARD_BOOST)`
  6. 计算卡牌最终权重：`final_weight = base_weight * (1 + card_boost.get(card_id, 0))`。
  7. 在该稀有度池内，基于 `final_weight` 进行加权随机选择卡牌。
  8. 若用户没有失败记录或映射为空，则退化为基础权重抽取。

- **伪代码**：
```text
# 输入：user_id
# 输出：selected_card（在已选稀有度池内）

# 1) 稀有度抽取
rarity_rates = load_rarity_drop_config()
chosen_rarity = weighted_random_choice(rarity_rates)
rarity_cards = query_cards_by_rarity(chosen_rarity)

# 2) 用户失败映射（level -> count）
failure_counts = LevelRecord.get_failure_counts_by_student(user_id)
failed_levels = [L for (L, c) in failure_counts.items() if c > 0]

# 3) 构建卡牌权重
if failed_levels is empty:
    adjusted_weights = [(card, base_weight(card)) for card in rarity_cards]
else:
    # 关卡 -> 知识点
    kp_rows = query("SELECT knowledge_point, level_name FROM knowledge_level_mapping WHERE level_name IN failed_levels")
    kp_fail_weight = dict()
    for row in kp_rows:
        kp = row.knowledge_point
        lvl = row.level_name
        kp_fail_weight[kp] = kp_fail_weight.get(kp, 0) + failure_counts[lvl]

    if kp_fail_weight is empty:
        adjusted_weights = [(card, base_weight(card)) for card in rarity_cards]
    else:
        # 知识点 -> 卡牌
        kps = list(kp_fail_weight.keys())
        kcm_rows = query("SELECT knowledge_point, card_id, relevance FROM knowledge_card_mapping WHERE knowledge_point IN kps")
        card_boost = dict()
        for row in kcm_rows:
            kp, cid, rel = row.knowledge_point, row.card_id, row.relevance or 1.0
            inc = kp_fail_weight[kp] * BOOST_PER_FAIL * rel
            card_boost[cid] = min(MAX_CARD_BOOST, card_boost.get(cid, 0.0) + inc)

        # 计算最终权重（仅对当前稀有度池生效）
        adjusted_weights = []
        for card in rarity_cards:
            base_w = card.drop_rate or 1.0
            boost = card_boost.get(card.card_id, 0.0)
            adjusted_weights.append((card, base_w * (1.0 + boost)))

# 4) 加权随机选择
selected_card = weighted_random_choice(adjusted_weights)
return selected_card
```

## 备注
- 概率调整常量：
  - 每次失败加成 `BOOST_PER_FAIL = 0.05`
  - 单卡最大加成 `MAX_CARD_BOOST = 0.5`
- 若未配置映射或失败记录为空，则按基础概率抽取。 